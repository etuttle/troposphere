#!/usr/bin/env python

import argparse
import itertools
import sys
import time
from ast import literal_eval

try:
    import boto
    import boto.cloudformation
except ImportError:
    print("boto 2.8.0+ is required")
    sys.exit(1)


def upload_template_to_s3(conn, bucket_name, key_name, template):
    cloudformation_bucket = conn.create_bucket(bucket_name,)
    key = cloudformation_bucket.new_key(key_name)
    key.set_contents_from_string(template)
    cfn_template_url = "https://s3.amazonaws.com/%s/%s" % (
        bucket_name, key_name)
    return cfn_template_url


def render_python_template(file):
    # By convention, templates render out json using the print builtin when
    # they are executed.  Since the print builtin is tricky to override, let's
    # just capture sys.stdout.

    from cStringIO import StringIO
    import sys
    import runpy

    capture = StringIO()

    try:
        sys.stdout = capture
        runpy.run_path(file)
    finally:
        sys.stdout = sys.__stdout__
        res = capture.getvalue()
        capture.close()

    return res


def create_stack(conn, stackname, template=None, url=None, params=None,
                 capabilities=None):
    try:
        if url:
            stack_id = conn.create_stack(stackname, template_url=url,
                                         parameters=params,
                                         capabilities=capabilities)
        else:
            stack_id = conn.create_stack(stackname, template,
                                         parameters=params,
                                         capabilities=capabilities)
    except boto.exception.BotoServerError as e:
        # XXX - need to figure out why this isn't getting parsed from boto.
        print("Error: %s" %
              (literal_eval(e.error_message)['Error']['Message'],))
        print("Exiting...")
        sys.exit(1)
    print("Created stack %s: %s" % (stackname, stack_id))


def build_s3_name(stack_name):
    timestamp = time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime())
    name = stack_name
    if stack_name.endswith('.json'):
        name = stack_name[:-5]
    if stack_name.endswith('.py'):
        name = stack_name[:-3]
    return '%s-%s.json' % (name, timestamp)


def describe_resources(conn, stackname):
    print(conn.describe_stack_resources(stackname))


class StackEventIterator:
    '''
    An iterator that blocks internally, polling AWS for new events.
    '''

    def __init__(self, conn, stack_id):
        self.conn = conn
        self.stack_id = stack_id
        self.last_event_id = None
        self.read_queue = []

    def __iter__(self):
        return self

    def next(self):
        while not len(self.read_queue):
            self.read_queue = self.__request_new()
            time.sleep(2)

        return self.read_queue.pop(0)

    def read_existing(self):
        result = self.read_queue
        self.read_queue = []
        result.extend(self.__request_new())
        return result

    def __request_all(self):
        next_token = None
        while True:
            page = self.conn.describe_stack_events(self.stack_id, next_token)
            for e in page:
                yield e
            next_token = page.next_token
            if next_token is None:
                break

    def __request_new(self):
        if self.last_event_id:
            req = itertools.takewhile(
                lambda e: e.event_id != self.last_event_id,
                self.__request_all())
        else:
            req = self.__request_all()

        response = list(req)

        if len(response):
            self.last_event_id = response[0].event_id

        response.reverse()
        return response


def print_event(e):
    print("%s %s %s" % (e.resource_status, e.resource_type, e.event_id))


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("-c", "--create", help="Create stack using template",
                        dest="create", )
    parser.add_argument("--capability",
                        help="Capability to allow (example: 'iam')",
                        dest="capabilities", action='append',
                        type=lambda s: 'CAPABILITY_' + s.upper(),
                        default=[])
    parser.add_argument("-b", "--bucket", help="Upload template to S3 bucket",
                        dest="s3bucket", required=False)
    parser.add_argument("-d", "--debug", help="Turn on boto debug logging",
                        dest="debug", required=False, action='store_true')
    parser.add_argument("-n", "--name", help="Template name in S3 bucket",
                        dest="s3name", required=False)
    parser.add_argument("-p", "--parameter", dest="params", action='append',
                        help="stack parameters in key=value form",)
    parser.add_argument("-r", "--region", help="Region (default us-east-1)",
                        dest="region", default="us-east-1")
    parser.add_argument("-R", "--resources", help="describe stack resources",
                        dest="resources", required=False, action='store_true')
    parser.add_argument("-t", "--tail", help="tail event log",
                        dest="tail", required=False, action='store_true')
    parser.add_argument("stack")
    values = parser.parse_args()

    if values.params:
        values.params = [x.split('=') for x in values.params]
    else:
        values.params = []

    if values.debug:
        import logging
        logging.basicConfig(filename="boto.log", level=logging.DEBUG)

    conn = boto.cloudformation.connect_to_region(values.region)

    if values.create:
        # Render or read the template file
        if values.create.endswith(".py"):
            template = render_python_template(values.create)
        else:
            template = open(values.create).read()

        # If needed, build an S3 name (key)
        if values.s3bucket and not values.s3name:
            values.s3name = build_s3_name(values.create)

        if values.s3bucket:
            # Upload to S3 and create the stack
            s3conn = boto.s3.connect_to_region(values.region)
            url = upload_template_to_s3(
                s3conn, values.s3bucket, values.s3name, template)
            create_stack(conn, values.stack, None, url, values.params,
                         values.capabilities)
        else:
            # Upload file as part of the stack creation
            create_stack(conn, values.stack, template, None, values.params,
                         values.capabilities)

    if values.resources:
        describe_resources(conn, values.stack)

    if values.tail:
        for event in StackEventIterator(conn, values.stack):
            print_event(event)
